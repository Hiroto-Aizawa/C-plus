// https://atcoder.jp/contests/apg4b/tasks/APG4b_y

// 【数値型】

/*
キーポイント
・整数型には扱える値の範囲が決まっている
・計算の途中で扱える範囲を超えることを **オーバーフロー** といい、正しく計算が行えなくなる
・int型より大きい値を扱いたいときはint64_t型を使う
・double型の値を出力する際に出力する小数点以下の桁数を指定するには以下のようにする
> cout << fixed << setprecision(桁数);

・(型)値で型変換（**キャスト**）を行うことができる
・暗黙的にキャストが起こる場合もある

【数値型】
【int64_t型】

今まで整数を扱う場合はint型を使ってきましたが、int型が表せる範囲は以下の通りに限られています。

最小値：-2147483648
最大値：2147483647
計算の途中でこの範囲を超えてしまうことを **オーバーフロー** と言います。
オーバーフローすると正しく計算が行えなくなります。
*/

#include <bits/stdc++.h>
using namespace std;
int main() {
  int a = 2000000000;
  int b = a * 2;
  cout << b << endl;

  int c = (a * 10 + 100) / 100;
  cout << c << endl;
  /*
  【実行結果】
  -294967296
  -14748363
  */
}

/*
2000000000 * 2の結果として4000000000が出力されてほしいところですが、
-294967296という値が出力されてしまっています。
また、(2000000000 * 10 + 100) / 100の結果は正しく計算できていれば200000001となるので、
オーバーフローせずに済むように思えますが、
2000000000 * 10の時点で計算結果がint型の範囲を超えてしまうので、
最終的な計算結果も正しくない-14748363という値が出力されています。

もっと広い範囲の値を扱いたい場合、int64_t型を使うのが一般的です。
int64_t型で扱える値の範囲は以下のとおりです。
・最小値：-9223372036854775808
・最大値：9223372036854775807
*/

#include <bits/stdc++.h>
using namespace std;
int main() {
  int64_t a = 2000000000;
  int64_t b = a * 2;
  cout << b << endl;
  /*
  【実行結果】
  4000000000
  */
}

/*
int型は20億(2 * 10^9)くらいまでと覚えておき、
それより大きな値が出てきそうであればint64_t型を使うようにしましょう。
int64_t型よりも大きな値を扱う方法もありますが、ここでは説明しません。
気になる人は調べてみてください。

プログラム中に直接10のように値を書くと、それはint型の数値として扱われます。
int64_t型として扱ってほしい場合は `10LL` のように末尾に `LL` をつけましょう。

また、int型とint64_t型の計算結果はint64_t型になります。
*/

#include <bits/stdc++.h>
using namespace std;
int main() {
  cout << 2000000000 * 2 << endl;     // int * int         -> int
  cout << 2000000000LL * 2LL << endl; // int64_t * int64_t -> int64_t
  cout << 2000000000LL * 2 << endl;   // int64_t * int     -> int64_t
  /*
  【実行結果】
  -294967296
  4000000000
  4000000000
  */
}

/*
【double型】

double型を出力する場合、通常通りcoutで出力してしまうと適当な桁で四捨五入されて表示されてしまいます。
途中の桁まで四捨五入せずに確実に表示したい場合、以下のように書きます。

>cout << fixed << setprecision(桁数);
*/

#include <bits/stdc++.h>
using namespace std;

int main() {
  cout << 3.14159265358979 << endl;

  // 小数点以下10桁まで
  cout << fixed << setprecision(10);

  cout << 3.14159265358979 << endl;
  /*
  【実行結果】
  3.14159
  3.1415926536
  */
}


/*
【明示的な数値型同士の変換】

int型とint64_t型の計算結果がint64_t型であったり、
int型とdouble型の計算結果がdouble型であったりするように異なる型同士でも計算できることがありました。
計算せずに、ただ型の変換だけを行うこともできます。型変換のことをキャストと言います。

C++には様々なキャスト方法がありますが、ここでは最も原始的なものを紹介します。
キャストの記法は以下のとおりです。

> （型）値
以下は数値型を変換する例です。
*/

#include <bits/stdc++.h>
using namespace std;

int main() {
  // 小数点以下5桁まで
  cout << fixed << setprecision(5);

  int a = 5;
  cout << (double)a << endl; // int型の値をdouble型に変換

  double b = 3.141592;
  cout << (int)b << endl; // double型の値をint型に変換
  /*
  【実行結果】
  5.00000
  3
  */
}

/*
1行目の出力では、int型の値をdouble型にキャストしたことで、出力時に小数点以下の数も表示されています。
2行目の出力では、double型の値をint型にキャストしたことで、小数点以下が切り捨てられて整数として表示されています。
double型をint型にキャストすると小数点以下切り捨てになることは重要なので覚えておきましょう。

int型とdouble型に限らず、様々な型同士がキャストできます。
ただし、int型からstring型への変換のように、数値型以外への変換は基本的にはできないということに注意してください。

> int N = 12345;
> string S = (string)N;  // コンパイルエラー
*/

/*
【暗黙的な数値型同士の変換】

計算の際に自動的にキャストが起こることもあります。
異なる数値型同士で計算を行う場合、以下の表のようにキャストされてから計算されます。

【型の組み合わせ】     【暗黙的なキャスト】    【計算結果の型】
int型とdouble型        int型→double型         double型
int型とint64_t型       int型→int64_t型        int64_t型
double型とint64_t型    int64_t型→double型     double型

また以下のような場合にも自動的にキャストが起こります。
・別の型の変数へ代入しようとした場合
・関数の引数に別の型の値を渡す場合

次のプログラムは暗黙的なキャストが生じる例です。
*/

#include <bits/stdc++.h>
using namespace std;

void print_int(int x) {
  cout << "x = " << x << endl;
}

int main() {
  double a = 1.2345;
  int b = 1;

  // aがdouble型に変換されてからbとの足し算が行われる
  // cout << a + (double)b << endl; と同じ結果
  cout << a + b << endl;

  int c = 2000000000;
  int64_t d = 100;
  // 初めにcがint64_t型へ変換されてからdとの掛け算が行われる
  // cout << (int64_t)c * d << endl; と同じ結果
  cout << c * d << endl;

  double e = 3.141592;
  int f = e;  // ここでdouble型からint型への変換が起こる(小数点以下が切り捨てられて3になる)
  cout << f << endl;

  // int型を引数に取る関数にdouble型を渡す
  print_int(e);  // int型に変換されてから関数が実行される
  /*
  【実行結果】
  2.2345
  200000000000
  3
  x = 3
  */
}

//なお、上の条件を満たす場合でも、キャストが行えない場合はコンパイルエラーとなります。

#include <bits/stdc++.h>
using namespace std;

void print_int(int x) {
  cout << "x = " << x << endl;
}

int main() {
  string s = "12345";

  int x = s;     // コンパイルエラー
  print_int(s);  // コンパイルエラー
}

/*
関数の引数に別の型の値を渡す場合でも、STLのmin関数やmax関数のように暗黙的な型変換が行われない関数もあるという点に注意してください。 
詳しくは4章の「テンプレート」で扱います。
*/

/*
【細かい話】
・double型の精度と誤差
*/

