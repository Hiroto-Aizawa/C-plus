// https://atcoder.jp/contests/apg4b/tasks/APG4b_w

// 【計算量】

/*
【キーポイント】
プログラムを実行するときには処理内容に応じた実行時間がかかる
コンピュータの記憶領域(メモリ)は有限であり、プログラムで変数を使用した分だけメモリを消費する
プログラムの実行時間・メモリ使用量が入力に応じてどのように変化するかを見積もったものを、それぞれ **時間計算量・空間計算量** という
計算量の表記には **オーダー記法** を用いることが多い

【アルゴリズム】
ある処理を行うプログラムを作成するときに、どのような計算を行っていくかという計算手順のことをアルゴリズムといいます。
例えば、1から100までの総和を計算するプログラムを考えます。 
1+2+3+...+99+100と順番に足していくというのは1つのアルゴリズムです。これをアルゴリズムAとします。 
一方、
100⋅(1+100)
__________
     2​

という式を用いて計算するというのもアルゴリズムです。これをアルゴリズムBとします。
この例のように、プログラムを作成するにあたって複数のアルゴリズムが考えられることがあります。 そのような場合には、どちらのアルゴリズムを用いるのかを選ぶことになります。
コンピュータの一回の計算には僅かに時間が掛かるので、計算回数が多くなるほど実行時間が長くなります。
より計算回数が少ないアルゴリズムを選択することによって、高速に動作するプログラムを作成できます。
上の例でのアルゴリズムAは99回の足し算が必要ですが、アルゴリズムBでは足し算・掛け算・割り算の計3回の計算で結果を求めることができます。 
99回の計算が必要なアルゴリズムAと、3回の計算が必要なアルゴリズムB、というように必要な計算の回数で大まかな性能を見積もることができます。
アルゴリズムの性能を比較する方法は色々ありますが、1つの指標として **計算量** という考え方があります。


【計算時間と記憶領域】
既に説明しましたが、コンピュータがプログラムを実行するときには、処理内容に応じた時間が掛かります。

コンピュータの記憶領域のことをメモリといいます。メモリは有限であり、変数を使用した分だけメモリを消費します。 
文字列や配列の変数は内部の要素数に応じてメモリを消費します。 
例えば、int型のN要素の配列はN個のint型の変数を使用したのと同じくらいのメモリを消費します。 
同様に長さNの文字列はN個のchar型の変数を使用したのと同じくらいのメモリを消費します。

【計算量】
プログラムは入力に対して必要な計算を行い、結果を出力します。 
このときに必要な計算時間や必要な記憶領域の量が、入力に対してどれくらい変化するかを示す指標を **計算量** といいます。

計算量には **時間計算量** と **空間計算量** があります。単に計算量という場合、時間計算量を指すことが多いです。

『時間計算量』
「プログラムの実行に必要な計算のステップ数が入力に対してどのように変化するか」という指標を　**時間計算量** といいます。
計算ステップ数とは、四則演算や数値の比較などの回数です。

『空間計算量』
「プログラムの実行に必要なメモリの量が入力に対してどのように変化するか」という指標を **空間計算量** といいます。
*/

#pragma region 計算量の例

//次のプログラムは1からNまでの総和(1+2+3+⋯+N)を計算するものです。

#include <bits/stdc++.h>
using namespace std;

int main() {
  int N;
  cin >> N;
  int sum = 0;
  for (int i = 1; i <= N; i++) {
    sum += i;
  }
  cout << sum << endl;
}

/*
このプログラムではfor文でN回の繰り返し処理を行っているので、計算ステップ数は入力のNに応じて変わります。 
N回の繰り返しを行うので、計算ステップ数はおおよそN回になります。 
このときの時間計算量は次で紹介するオーダー記法を用いてO(N)と表します。

このプログラムで使用している変数は入力のNに関わらずint Nとint sumとint iの3つです。 
このときの空間計算量はオーダー記法を用いてO(1)と表します。
*/

#pragma endregion

/*
【オーダー記法】
厳密な計算ステップ数や必要な記憶領域の量は実装に用いるプログラミング言語や実装方法などによって変わるので、 
計算量を厳密に見積もるのは大変です。

そこで時間計算量や空間計算量の表現として、オーダー記法 O(⋅)が用いられることが多いです。
例えば、3N^2 +7N+4という式はオーダー記法ではO(N 2 )と表されます。

以下の手順によってオーダー記法による表記を得ることができます。

    ステップ1：係数を省略する。ただし定数については1とする。
    ステップ2：Nを大きくしたときに一番影響が大きい項を取り出し、O(項)と書く。
        補足：N^2+N+1 という式の場合「N^2」「N」「1」それぞれを項といいます。

「一番影響が大きい項」というのは、
Nを大きくしていったときに「大きくなるスピードが最も速い項」と考えてください。 
例えばNとN^2 を比較すると、以下の表のようになるので3N^2 の方が影響が大きいといえます。

3N^2+7N+4という式をオーダー記法で表す場合の手順以下の通りです。
    ステップ1：係数を省略してN^2+N+1とします。
    ステップ2：N^2+N+1で一番影響が大きい項はN^2 なのでO(N^2 )とします。
同じように2N+10ならO(N)となります。


【例題】
次の式をそれぞれオーダー記法で表してください

1. N+100
2. 10N+N^3
3. 3+5
4. 2^N +N^2

答え
1. O(N)
2. O(N^3)
3. O(1)
4. O(2^N)
*/

#pragma region 計算量（オーダー記法）の求め方
/*
計算量を求めるには計算ステップ数がどうなるかを式で表す必要があります。

次のプログラムは意味の無いものですが、計算量がどうなるかを考えてみましょう。
*/
#include <bits/stdc++.h>
using namespace std;

int main() {
  int N;
  cin >> N;

  int sum = 0;

  // O(N^2)
  for (int i = 0; i < N; i++) {
    for (int j = 0; j < N; j++) {
      sum += i * j;
    }
  }

  // O(N)
  for (int i = 0; i < N; i++) {
    sum += i;
  }

  // O(N)
  for (int i = 0; i < N; i++) {
    sum *= i;
  }

  cout << sum << endl;

  /*
  1つの2重ループと2つの1重ループがあるので計算ステップ数は N^2 +2N くらいになります。 
  これをオーダー記法で表すと O(N^2) となります。 
  よってこのプログラムの時間計算量は O(N^2) です。

  このように、 簡単なアルゴリズムであれば厳密な式を求めなくても 
  「N回の繰り返し処理があるから O(N) 」や「0からNまで回す2重ループがあるから O(N^2) 」
   などと見積もることができます。
  */
}


#pragma endregion

#pragma region 例

/*
【 O(1) 】

次のプログラムは、1からNまでの総和を公式を使って計算するものです。 
このプログラムの計算量はO(1)です。
*/

#include <bits/stdc++.h>
using namespace std;

int main() {
  int N;
  cin >> N;
  //一度の計算なのでO(1)
  int sum = N * (N + 1) / 2;
  cout << sum << endl;
}

/*
【入力】
10
【実行結果】
55
*/

//////////////////////////////////////////////////////////////////////////

/*
【 O(N) 】

次のプログラムは要素数Nの配列の中に含まれる偶数の個数を数えるものです。 
このプログラムの計算量はO(N)です。
*/

#include <bits/stdc++.h>
using namespace std;

int main() {
  int N;
  cin >> N;
  vector<int> a(N);
  // 単一ループなのでO(N)
  for (int i = 0; i < N; i++) {
    cin >> a.at(i);
  }

  int cnt = 0;
  for (int i = 0; i < N; i++) {
    if (a.at(i) % 2 == 0) {
      cnt++;
    }
  }
  cout << cnt << endl;
}

/*
【入力】
5
1 4 2 5 9
【実行結果】
2
*/

//////////////////////////////////////////////////////////////////////////

/*
【 O(N^2) 】

次のプログラムは九九の要領でN×Nマスを埋めるものです。 
このプログラムの計算量はO(N 2 )です。
*/
#include <bits/stdc++.h>
using namespace std;

int main() {
  int N;
  cin >> N;

  vector<vector<int>> table(N, vector<int>(N));
  for (int i = 0; i < N; i++) {
    for (int j = 0; j < N; j++) {
      table.at(i).at(j) = (i + 1) * (j + 1);  // N×N回実行される
    }
  }

  // 出力
  for (int i = 0; i < N; i++) {
    for (int j = 0; j < N; j++) {
      cout << table.at(i).at(j);
      if (j != N - 1) {
        cout << " ";
      }
      else {
        cout << endl;
      }
    }
  }
}

/*
【入力】
9
【実行結果】
1 2 3 4 5 6 7 8 9
2 4 6 8 10 12 14 16 18
3 6 9 12 15 18 21 24 27
4 8 12 16 20 24 28 32 36
5 10 15 20 25 30 35 40 45
6 12 18 24 30 36 42 48 54
7 14 21 28 35 42 49 56 63
8 16 24 32 40 48 56 64 72
9 18 27 36 45 54 63 72 81
*/

//////////////////////////////////////////////////////////////////////////

/*
【 O(logN) 】

初めに簡単にlogを説明します。
logx Nという式は「xを何乗したらNになるか」を表します。 
例えば、2^4 =16なので、log2 16=4です。

長さ8の棒を長さが1になるまで半分に切る(2で割る)ことを繰り返したときに切る回数は **log2 8回** です。

8 → 4 → 2 → 1 

このように計算量に出てくるlogは「半分にする回数」を表すことが多いです。

補足：厳密な定義は高校数学の範囲なので詳しく知りたい人は別で勉強してください。
また、オーダー記法ではlogの底は省略して書かれることが多いです。この場合は2が省略されていると考えましょう。
実はlogの底の違いは定数倍の違いだけとみなすことができるので、係数を省略するオーダー記法では省略されます。

次のプログラムは
Nが2で何回割れるかを数えるものです。 
このプログラムの計算量はO(logN)です。
上に挙げたイメージと同じような処理を行うプログラムなので、ループする回数が大体log2 N回になることが分かります。
*/

#include <bits/stdc++.h>
using namespace std;

int main() {
  int N;
  cin >> N;
  int cnt = 0;
  while (N > 0) {
    cnt++;
    N /= 2;
  }
  cout << cnt << endl;
}

#pragma endregion

/*
【計算量のおおまかな大小】

主な計算量の大まかな大小は次のようになります。
** O(1) < O(logN) < O(N) < O(NlogN) < O(N^2) < O(2^N) **

1秒くらいで計算が終わるようなプログラムを作ろうというときは、 
入力の大きさの上限を見積もった上で1秒以内に収まるような計算量のアルゴリズムを選択する必要があります。

例えば、N=10^6 くらいまでの入力で1秒以内に計算を終えるプログラムを作成するのであれば、 
O(N^2)のアルゴリズムでは間に合わないので、O(N)のアルゴリズムを用いて実装する必要があります。

AtCoderの問題では実行時間制約が2秒くらいであることが多いです。 
コンテストに参加する人は、1秒あたり10^8 回くらいの計算ができることを覚えておきましょう。
*/