// https://atcoder.jp/contests/apg4b/tasks/APG4b_v

// 【再帰関数】

/*
【キーポイント】
・「ある関数の中で同じ関数を呼び出す」ことを **再帰呼び出し** という
・再帰を行うような関数を **再帰関数** という
・再帰呼び出しを行わずに完了できる処理を **ベースケース** という
・再帰呼出しを行い、その結果を用いて行う処理のことを **再帰ステップ** という
・再帰関数の実装方法3ステップ
・1.「引数」「返り値」「処理内容」を決める
・2.再帰ステップの実装
・3.ベースケースの実装

【再帰関数】
> 再帰関数を理解するためには関数を理解している必要があります。 1.15.関数の記憶が曖昧な人は復習しておきましょう。
> 再帰関数は難しいので、説明を読んでみて分からなかった場合はそのまま次に進んでもかまいません。

繰り返し処理を行う方法として、これまでforループやwhileループのようなループ構文を扱ってきました。
**再帰** も繰り返し処理を行う方法の一つです。

再帰とは「ある関数の中で同じ関数を呼び出す」ことです。また、このような関数のことを **再帰関数** といいます。

再帰はループ構文よりも強力な繰り返し手法で、ループ構文で書くのが難しいような処理を簡潔に行うことができます。
初めは分かりにくく感じるかもしれませんが、強力な手法なので使いこなせるようにしましょう。

例として、「0からnまでの総和を計算する関数」を考えます。

これは今まで扱ってきたforループやwhileループを用いて書くことができますが、再帰関数を用いて書くと次のようになります。
*/

#include <bits/stdc++.h>
using namespace std;

int sum(int n) {
  if (n == 0) {
    return 0;
  }

  // sum関数の中でsum関数を呼び出している
  // このような関数の呼び出しのことを **再帰呼び出し** と言います。
  int s = sum(n - 1);
  return s + n;
}

int main() {
  cout << sum(2) << endl;    // 0 + 1 + 2 = 3
  cout << sum(3) << endl;    // 0 + 1 + 2 + 3 = 6
  cout << sum(10) << endl;   // 0 + 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10 = 55
  /*
  【実行結果】
  3
  6
  55
  */
}

/*
【再帰関数の動作】
次のスライドは上のsum関数をsum(3)として呼び出したときの動作を説明したものです。
 https://www.slideshare.net/APG4b/apg4b-205-sum

再帰関数は関数名が同じなので自分自身を呼び出しているように感じられて動作が分かりにくく思えるかもしれません。
その場合は「引数の異なる呼び出しでは別の関数を呼んでいる」と考えるといいです。

上の例でsum(3)を呼び出したときの動作を書き出してみます。

sum(3)ではsum(2)を呼び出してその結果に3を足して返します。
sum(2)ではsum(1)を呼び出してその結果に2を足して返します。
sum(1)ではsum(0)を呼び出してその結果に1を足して返します。
sum(0)は0を返します。


*/


#pragma region 例題
/*
問題文
あなたはA社を経営する社長です。 A社はN個の組織からなり、それぞれに0番からN−1番の番号が付いています。 
0番の番号が付いた組織はトップの組織です。

組織間には親子関係があり、0番以外のN−1個の組織には必ず1つの親組織があります。 子組織は複数になることがあります。 
また、それぞれの組織は直接的または間接的にトップの組織と関係があるものとします。

あなたは全ての組織に報告書を提出するように求めました。
混雑を避けるために、「各組織は子組織の報告書がそろったら、自身の報告書を加えて親組織に送る」ことを繰り返します。 
子組織が無いような組織は自身の報告書だけをすぐに親組織に送ります。

ある組織から報告書を送ってから、その親組織が受け取るときにかかる時間を1分とします。
あるタイミングで一斉に報告書の伝達を開始したときに、トップの組織の元に全ての組織の報告書が揃う時刻（伝達を始めてから何分後か）を求めてください。 
なお、各組織の報告書は既に準備されているため、報告書の伝達以外の時間はかからないこととします。

【入力例】
6
0 0 1 1 4
【実行結果】
3
*/

#include <bits/stdc++.h>
using namespace std;

// x番の組織について、子組織からの報告書が揃った時刻を返す
// childrenは組織の関係を表す2次元配列(参照渡し)
int complete_time(vector<vector<int>> &children, int x) {
  // (ここに追記して再帰関数を実装する)
  
  // 子組織がない場合は時間がかからないので0を返す
  if(x == children[x].size()) return 0;
  
  // 最大所要時間
  int max_time = 0;
  
  //x番の組織の子組織についての処理を行う
  for(int child : children(x)){
    //所要時間
    int time = complete_time(children, child) + 1;
    
    max_time = max(max_time, time);
  }
  return max_time;
}

// これ以降の行は変更しなくてよい

int main() {
  int N;
  cin >> N;

  vector<int> p(N);  // 各組織の親組織を示す配列
  p.at(0) = -1;  // 0番組織の親組織は存在しないので-1を入れておく
  for (int i = 1; i < N; i++) {
    cin >> p.at(i);
  }

  // 組織の関係から2次元配列を作る(理解しなくてもよい)
  vector<vector<int>> children(N);  // ある組織の子組織の番号一覧  // N×0の二次元配列
  for (int i = 1; i < N; i++) {
    int parent = p.at(i);  // i番の親組織の番号
    children.at(parent).push_back(i);  // parentの子組織一覧にi番を追加
  }

  // 0番の組織の元に報告書が揃う時刻を求める
  cout << complete_time(children, 0) << endl;
}


#pragma endregion