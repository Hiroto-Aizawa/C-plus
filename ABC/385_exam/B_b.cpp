// https://atcoder.jp/contests/abc385/tasks/abc385_b

//【Santa Cluas 1】

/*
【問題文】
縦 H 行横 W 列のマス目があります。
上から i 行目、左から j 列目のマスをマス (i,j) と表します。

マス (i,j) は Si,jが # のとき通行不可能、. のとき通行可能であり家が建っていない、
@ のとき通行可能であり家が建っていることを表します。

最初、マス (X,Y) にサンタクロースがいます。
サンタクロースは文字列 T に従って以下の行動を行います。

・文字列 T の長さを ∣T∣ とする。i=1,2,…,∣T∣ の順に以下のように移動する。
　・現在サンタクロースがいるマスを (x,y) とする。
　　・Ti が U かつマス (x−1,y) が通行可能ならマス (x−1,y) に移動する。
　　・Ti が D かつマス (x+1,y) が通行可能ならマス (x+1,y) に移動する。
　　・Ti が L かつマス (x,y−1) が通行可能ならマス (x,y−1) に移動する。
　　・Ti が R かつマス (x,y+1) が通行可能ならマス (x,y+1) に移動する。
　　・それ以外の場合、マス (x,y) に留まる。

行動を終えたあとにサンタクロースがいるマスと、行動により通過または到達した家の数を求めてください。
ただし、同じ家を複数回通過または到達してもそれらは重複して数えません。

【制約】
・3≤H,W≤100
・1≤X≤H
・1≤Y≤W
・与えられる数値は全て整数である
・Si,j は #, ., @ のいずれか
・全ての 1≤i≤H について Si,1 ,Si,W は #
・全ての 1≤j≤W について S1,j ,SH,j は #
・SX,Y = .
・T は U, D, L, R のいずれかからなる長さ 1 以上 10＾4 以下の文字列

【入力】
入力は以下の形式で標準入力から与えられる。

H W X Y
S1,1 S1,2 …S1,W
…
SH,1 SH,2 …SH,W
T

【出力】
行動を終えたあとサンタクロースがいるマスを (X,Y)、
行動により通過または到達した家の数を C とするとき、
X,Y,C をこの順に空白区切りで出力せよ。
*/

#pragma region 提出版

#include <bits/stdc++.h>
using namespace std;

int main() {
  int h, w, x, y;
  //家を通過した数
  int cnt = 0;
  cin >> h >> w >> x >> y;
  
  //配列は0番目から始まるのでn-1をして配列に基準を合わせる
  x--;
  y--;
  
  //本来charの2次元配列だが、配列の要素をstring型にすることで
  //1次元配列として、h行分の入力ですべての要素を格納できる
  vector<string> s(h);
  for (int i = 0; i < h; i++) {
    cin >> s[i];
	}

  string t;
  cin >> t;
  
  for(char c : t){
    if(c == 'U' && s[x-1][y] != '#') x--;
    if(c == 'D' && s[x+1][y] != '#') x++;
    if(c == 'L' && s[x][y-1] != '#') y--;
    if(c == 'R' && s[x][y+1] != '#') y++;
    
    if(s[x][y] == '@'){
      s[x][y] = '.';
      cnt++;
    }
  }
  
  //配列基準にn-1値をnに戻す
  x++;
  y++;
  
  cout << x << " " << y << " " << cnt << endl;
}

#pragma endregion